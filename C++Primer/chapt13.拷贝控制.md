# 第十三章：拷贝控制  

- [第十三章：拷贝控制](#第十三章拷贝控制)
  - [拷贝、赋值、销毁](#拷贝赋值销毁)
    - [拷贝构造函数](#拷贝构造函数)
    - [拷贝赋值运算符](#拷贝赋值运算符)
    - [析构函数](#析构函数)
    - [使用 =default](#使用-default)
    - [阻止拷贝 =delete](#阻止拷贝-delete)
  - [拷贝控制与资源管理](#拷贝控制与资源管理)
  - [交换操作](#交换操作)
  - [对象移动](#对象移动)
    - [移动构造函数](#移动构造函数)

---

## 拷贝、赋值、销毁  

### 拷贝构造函数  

* 参数是引用类型（一般同时是 `const` 的），不是 `explicit` 的。  
* 默认情况下，编译器合成拷贝控制构造函数。  
* 拷贝初始化发生在：  
  * 用 `=` 定义变量。  
  * 将一个对象作为实参传递给一个非引用类型。  
  * 将一个返回类型为非引用类型的函数返回一个对象。  
  * 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。  
  * 标准库容器中的 `insert` 或 `push` 成员。（ `emplace` 创建成员使用直接初始化）  
  ```c++
  class Foo
  {
  public:
      Foo();
      Foo(const Foo& a): n(a.n) {}  // 拷贝构造函数
  private:
      int n = 0;
  }
  ```

### 拷贝赋值运算符  

拷贝赋值运算符就是一个名为 `operator=` 的函数。  
* 拷贝赋值运算符接收一个与其所在类相同类型的参数。  
* 通常返回一个指向其左侧运算对象的引用。（为了与标准库保持一致）  
* 编译器合成默认拷贝函数。  
* **将一个对象赋予它自身，赋值运算符必须可以正确工作**。  
* 大多数赋值运算符组合了析构函数和构造函数。  
  ```c++
  class Foo
  {
  public:
      Foo();
      Foo& operator=(const Foo& a)  // 拷贝赋值运算符
      {
          n = a.n;
          return *this;
      }
  private:
      int n = 0;
  }
  ```

### 析构函数  

* **析构函数先执行结构体，然后销毁成员**。析构函数体自身并不直接销毁成员。    
* 需要析构函数的类也需要拷贝和赋值操作。比如：存在成员变量是指针，指向动态分配的内存。  
* 需要拷贝构造函数/拷贝赋值运算符，不意味着需要析构函数。比如：使用一个变量保存每个对象的 id 。  

### 使用 =default  

* 可以把拷贝构造函数、拷贝赋值操作符和析构函数使用 `=default` 修饰，显示指定编译器合成版本。  
* 类内使用，表示内联版本。  

### 阻止拷贝 =delete  

* `=delete` 必须出现在函数第一次声明的时候。  
* 可以对任何函数使用。  
* 不要对析构函数使用 `=delete` ，这会让对象无法销毁。但是可以动态分配这种类对象，只是无法删除回收内存。  

## 拷贝控制与资源管理  

* 可以定义拷贝操作，使类的行为看起来像一个指针或值。  

## 交换操作  

* 标准库定义了 swap 函数操作，交换两个对象。类也可以自定义 swap 操作。编译器使用函数重载来匹配对应的函数。  
* 基于上面的原因，应该使用 swap 而不是 std::swap 。  
* 定义了 swap 的类，通常使用 swap 来实现赋值运算符。这样可以自动处理字符值的情况，且天然是异常安全的。    
  ```c++
  void swap(Foo &lhs, Foo &rhs)
  {
      using std::swap;
      swap(lhs.n, rhs.n);
  }
  Foo& operator=(const Foo rhs)  // 参数不是引用。
  {
      swap(*this, rhs)
      return *this;
  }
  ```

## 对象移动  

C++ 新标准一个重要特性是支持对象移动。  

* **右值引用**，使用 && 而非 & 来获取右值引用。  
* 右值引用一个重要特性是，只能引用**右值**，是将要销毁的对象。一般而言，一个左值表达式表示对象的身份；一个右值表达式表示对象的值，比如运算表达式。  
* 标准库提供 move 函数把一个左值显示变成右值，意味着使用之后，源对象值将是未定义的。  
  ```c++
  int rr1 = 100;
  int &&rr2 = std::move(rr1);
  ```

### 移动构造函数  

* 参数是一个右值引用。  
* 使用 noexcept 通知标准库不应抛出任何异常。放在函数参数列表后，初始化列表的冒号之前。  
* 必须在类头文件的声明中和定义中都指定 noexcept 。  
* 移动后，源对象必须可以直接进行析构状态。  
* 合成的移动构造操作使用拷贝构造操作来代替移动操作。  
  ```c++
  Foo& Foo::operator=(Foo &&rhs) noexcept  // 参数不是引用。
  {
      n = ths.n;
      return *this;
  }
  ```


